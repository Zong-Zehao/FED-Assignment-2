<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Random Song Preview</title>
    <style>
        body {
            font-family: 'Arial', sans-serif;
            text-align: center;
            margin: 20px;
        }

        #result {
            margin-top: 20px;
        }

        .options {
            display: flex;
            justify-content: space-around;
            margin-top: 10px;
        }

        .option-button {
            padding: 10px;
            cursor: pointer;
        }
    </style>
</head>

<body>
    <h1>Random Song Preview</h1>
    <p>Points: <span id="points">0</span></p>
    <button onclick="getRandomSong()">Get Random Song</button>
    <button onclick="skipSong()">Skip</button>
    <div id="result"></div>
    <div class="options" id="options"></div>

    <script>
        let fetchingSong = false;
        let audioPlayer;
        let currentTrackId;
        let points = 0;
        let timer;
        let startTime; // Variable to store the start time when displaying options

        const getRandomTrackId = async () => {
            const playlistUrl = 'https://deezerdevs-deezer.p.rapidapi.com/playlist/3155776842'; // Example playlist
            const playlistOptions = {
                method: 'GET',
                headers: {
                    'X-RapidAPI-Key': '57c85ed06fmsh39d26ca54fd5307p130ecejsn6bd33960a5cb',
                    'X-RapidAPI-Host': 'deezerdevs-deezer.p.rapidapi.com'
                }
            };

            try {
                const response = await fetch(playlistUrl, playlistOptions);
                const playlistData = await response.json();
                const randomIndex = Math.floor(Math.random() * playlistData.tracks.data.length);
                const newTrackId = playlistData.tracks.data[randomIndex].id.toString();

                // Ensure the newly fetched song is different from the current one
                if (newTrackId !== currentTrackId) {
                    currentTrackId = newTrackId;
                    return currentTrackId;
                } else {
                    // If the new song is the same, recursively call to get another random song
                    return getRandomTrackId();
                }
            } catch (error) {
                console.error(error);
                throw error;
            }
        };

        const getTrackDetails = async (trackId) => {
            const trackUrl = `https://deezerdevs-deezer.p.rapidapi.com/track/${trackId}`;
            const trackOptions = {
                method: 'GET',
                headers: {
                    'X-RapidAPI-Key': '57c85ed06fmsh39d26ca54fd5307p130ecejsn6bd33960a5cb',
                    'X-RapidAPI-Host': 'deezerdevs-deezer.p.rapidapi.com'
                }
            };

            try {
                const response = await fetch(trackUrl, trackOptions);
                const result = await response.json();
                return {
                    title: result.title,
                    preview: result.preview
                };
            } catch (error) {
                console.error(error);
                throw error;
            }
        };

        const displayResult = (title, preview, options) => {
            const resultDiv = document.getElementById('result');
            resultDiv.innerHTML = `
                <h2>Song Title: ${title}</h2>
                <audio controls autoplay crossorigin="anonymous" controlsList="nodownload" id="audioPlayer">
                    <source src="${preview}" type="audio/mp3">
                    Your browser does not support the audio element.
                </audio>
            `;

            const optionsDiv = document.getElementById('options');
            optionsDiv.innerHTML = options.map(option => `
                <button class="option-button" onclick="checkAnswer('${encodeURIComponent(option)}', '${encodeURIComponent(title)}')">${option}</button>
            `).join('');

            audioPlayer = document.getElementById('audioPlayer');
            startTimer();
            startTime = new Date(); // Record the start time when displaying options
        };

        const getRandomSong = async () => {
            if (!fetchingSong) {
                fetchingSong = true;
                try {
                    resetTimer();
                    const randomTrackId = await getRandomTrackId();
                    const { title, preview } = await getTrackDetails(randomTrackId);
                    console.log('Fetched Song:', JSON.stringify(title)); // Log the fetched song title
                    const wrongOptions = generateWrongOptions(title);
                    const allOptions = shuffleArray([...wrongOptions, title]);
                    displayResult(title, preview, allOptions);
                } catch (error) {
                    console.error(error);
                } finally {
                    fetchingSong = false;
                }
            }
        };

        const skipSong = () => {
            resetTimer();
            getRandomSong();
        };

        const generateWrongOptions = (correctAnswer) => {
            const wrongOption1 = generateFakeSongName();
            const wrongOption2 = generateFakeSongName();
            while (wrongOption1 === wrongOption2) {
                // Ensure the wrong options are distinct
                wrongOption2 = generateFakeSongName();
            }
            return [wrongOption1, wrongOption2];
        };

        const generateFakeSongName = () => {
            // Generate a random fake song name with diverse variations
            const baseWords = ['Mystic', 'Eternal', 'Sonic', 'Harmonic', 'Whispering', 'Rhythmic'];
            const prefixes = ['Enchanted', 'Celestial', 'Serenading', 'Astral', 'Melodic', 'Epic'];
            const suffixes = ['Symphony', 'Melody', 'Harmony', 'Vibration', 'Sonata', 'Rhythm'];

            const randomBase = baseWords[Math.floor(Math.random() * baseWords.length)];
            const randomPrefix = prefixes[Math.floor(Math.random() * prefixes.length)];
            const randomSuffix = suffixes[Math.floor(Math.random() * suffixes.length)];

            const variations = [
                `${randomBase} ${randomSuffix}`,
                `${randomPrefix} ${randomBase}`,
                `${randomBase} ${randomSuffix}`,
                `${randomBase} & ${randomPrefix}`,
                `${randomBase}'s ${randomSuffix}`
            ];

            return variations[Math.floor(Math.random() * variations.length)];
        };

        const shuffleArray = (array) => {
            for (let i = array.length - 1; i > 0; i--) {
                const j = Math.floor(Math.random() * (i + 1));
                [array[i], array[j]] = [array[j], array[i]];
            }
            return array;
        };

        const checkAnswer = async (selectedOption, correctAnswer) => {
            const resultDiv = document.getElementById('result');
            const pointsSpan = document.getElementById('points');
            const sanitizedSelectedOption = encodeURIComponent(selectedOption);
            const sanitizedCorrectAnswer = encodeURIComponent(correctAnswer);

            const endTime = new Date(); // Record the end time when the user makes a selection
            const timeDifferenceInSeconds = Math.floor((endTime - startTime) / 1000);

            if (sanitizedSelectedOption === sanitizedCorrectAnswer) {
                points += 30; // Add 30 points for correct answer
                resultDiv.innerHTML += `<p style="color: green;">Correct! Earned 30 points.</p>`;
            } else {
                // Subtract the time taken from the points for wrong answers
                points = Math.max(0, points - timeDifferenceInSeconds);
                resultDiv.innerHTML += `<p style="color: red;">Wrong! Deducted ${timeDifferenceInSeconds} points.</p>`;
            }

            pointsSpan.textContent = points;
            resetTimer();
            // Proceed to the next song
            getRandomSong();
        };

        const startTimer = () => {
            timer = setInterval(() => {
                if (points > 0) {
                    points--;
                    document.getElementById('points').textContent = points;
                }
            }, 1000);
        };

        const resetTimer = () => {
            clearInterval(timer);
        };
    </script>
</body>

</html>
